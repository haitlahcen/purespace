-- Geometry.hs ---

-- Copyright (C) 2018 Hussein Ait-Lahcen

-- Author: Hussein Ait-Lahcen <hussein.aitlahcen@gmail.com>

-- This program is free software; you can redistribute it and/or
-- modify it under the terms of the GNU General Public License
-- as published by the Free Software Foundation; either version 3
-- of the License, or (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program. If not, see <http://www.gnu.org/licenses/>.

module PureSpace.Common.Game.Geometry
  (
    module Linear,
    module PureSpace.Common.Game.Types,
    Rectangle,
    bounds,
    overlaps,
    pointInRectangle,
    pointInCircle,
    direction,
    directionAngle
  )
  where

import           Linear                      hiding (angle, identity)
import           PureSpace.Common.Game.Types

-- TODO: extract common behavior in a 'Shape' typeclass

-- top left, bot right
type Rectangle = (Position, Position)

bounds :: Position -> Float -> Float -> Rectangle
bounds p w h =
  let q = (/ 2) <$> V2 w h
      pq = (+ p) . (* q)
  in (pq $ V2 (-1)  (-1),
      pq $ V2   1     1)

pointInCircle :: Position -> Float -> Position -> Bool
pointInCircle (V2 cx cy) r (V2 x y) =
  let dx = abs (x - cx)
      dy = abs (y - cy)
  in dx*dx + dy*dy < r*r

pointInRectangle :: Rectangle -> Position -> Bool
pointInRectangle (V2 a b, V2 c d) (V2 x y) =
  let xIsInside = x >= a && x <= c
      yIsInside = y >= b && y <= d
  in xIsInside && yIsInside

overlaps :: Rectangle -> Rectangle -> Bool
overlaps p@(aa, ab) q@(ba, bb) =
  let pContains = pointInRectangle p
      qContains = pointInRectangle q
  in qContains aa ||
     qContains ba ||
     pContains ab ||
     pContains bb

direction :: Position -> Position -> Direction
direction a b = b - a

-- update an angle with the given direction
-- if the direction is null, it stay the same
directionAngle :: Direction -> Angle -> Angle
directionAngle (V2 0 0) phi = phi
directionAngle (V2 x y) _   = atan2 y x

